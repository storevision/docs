{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Storevision Webstore Frontend","text":""},{"location":"#about-the-project","title":"About the project","text":"<p>This project is a webstore written for a school project. The frontend uses the framework Next.js, which is a React framework. The frontend code is written in TypeScript. There are two backends for the project:</p> <ul> <li>C# Backend (Documented here)</li> <li>Node.js Backend (Documented here)</li> </ul>"},{"location":"CS-Backend/","title":"About the C# backend","text":"<p>This is the C# backend developed by @afercher.</p>"},{"location":"CS-Backend/#database","title":"Database","text":"<p>The database is initialized through a couple of SQL scripts.</p> <p>The final database looks like this:</p> <p></p>"},{"location":"CS-Backend/CS-Backend/","title":"C# Backend Project Overview","text":""},{"location":"CS-Backend/CS-Backend/#backend-definition","title":"Backend Definition","text":"<p>The Webstore Backend project is a server-side application designed to manage the core functionalities of an online store. It provides APIs for user authentication, product management, order processing, and other essential e-commerce operations. This backend interacts with databases, handles business logic, and ensures secure communication with clients.</p> <p>Backend Features:</p> <ul> <li>User authentication and authorization using JWT tokens.</li> <li>Order creation and tracking.</li> <li>Integration with third-party services.</li> <li>Secure and scalable architecture.</li> </ul>"},{"location":"CS-Backend/CS-Backend/#architecture","title":"Architecture","text":"<p>The backend is developed using the following architecture and technologies:</p> <p>Architecture:</p> <ul> <li>Layered Architecture: Separation of concerns with controllers, services, and repositories.</li> <li>RESTful APIs: Exposes endpoints for client applications to interact with the backend.</li> <li>Containerization: Dockerized setup for consistent deployment.</li> </ul> <p>Technologies:</p> <ul> <li>Programming Language: C# (.NET 9). Official Documentation</li> <li>Framework: ASP.NET Core for building APIs. ASP.NET Core Documentation</li> <li>Database: PostgreSQL. PostgreSQL Documentation</li> <li>Authentication: JWT tokens for secure user sessions. JWT.io Documentation</li> <li>Dependency Injection: Built-in .NET Core DI framework. Dependency Injection Documentation</li> <li>Configuration Management: JSON configuration files and environment variables. Configuration in .NET</li> <li>Containerization: Docker and Docker Compose for deployment. Docker Documentation | Docker Compose Documentation</li> </ul>"},{"location":"CS-Backend/CS-Backend/#use-cases","title":"Use Cases","text":""},{"location":"CS-Backend/CS-Backend/#user-registration","title":"User Registration","text":"<p>Scenario: A user can register on the application by providing necessary details such as email, username, and password.</p> <p>Flow:</p> <ol> <li>User provides registration details via a client application.</li> <li>If valid, the backend creates a new user record in the database and encrypts the password for security.</li> <li>The user receives a success message upon successful registration.</li> </ol>"},{"location":"CS-Backend/CS-Backend/#user-login","title":"User Login","text":"<p>Scenario: A user logs in.</p> <p>Flow:</p> <ol> <li>The user submits their login credentials via the frontend.</li> <li>The backend validates the credentials against the database.</li> <li>If valid, an authentication token is generated and returned to the frontend.</li> <li>The frontend stores the token securely for subsequent requests.</li> </ol> <p>Scenario: A user logs out.</p> <p>Flow:</p> <ol> <li>The user initiates a logout request via the frontend.</li> <li>The frontend clears the locally stored authentication token.</li> <li>A confirmation of the logout is returned to the frontend.</li> </ol> <p>Scenario: A user stays logged in (handled via token).</p> <p>Flow:</p> <ol> <li>Upon login, the backend issues a token with an expiration period (e.g., a JWT).</li> <li>The frontend includes the token in subsequent API requests for authentication.</li> <li>The backend validates the token on each request to ensure it is still valid.</li> <li>If the token is expired or invalid, the user is prompted to log in again.</li> </ol>"},{"location":"CS-Backend/CS-Backend/#cart-management","title":"Cart Management","text":"<p>Scenario: A user adds a new product to the cart.</p> <p>Flow:</p> <ol> <li>The user selects a product and submits an \"add to cart\" request via the frontend.</li> <li>The backend validates the product ID and checks availability.</li> <li>The product is added to the user's cart in the database.</li> <li>The updated cart data is returned to the frontend.</li> </ol> <p>Scenario: A user removes a product from the cart.</p> <p>Flow:</p> <ol> <li>The user selects a product to remove and submits a \"remove from cart\" request.</li> <li>The backend verifies the product exists in the user's cart.</li> <li>The product is removed from the cart in the database.</li> <li>The updated cart data is returned to the frontend.</li> </ol> <p>Scenario: A user increases the quantity of a product in the cart.</p> <p>Flow:</p> <ol> <li>The user selects a product and submits an \"increase quantity\" request.</li> <li>The backend verifies the product is in the cart and checks stock availability.</li> <li>The quantity of the product in the cart is updated in the database.</li> <li>The updated cart data is returned to the frontend.</li> </ol> <p>Scenario: A user decreases the quantity of a product in the cart.</p> <p>Flow:</p> <ol> <li>The user selects a product and submits a \"decrease quantity\" request.</li> <li>The backend verifies the product is in the cart and ensures the quantity doesn't drop below zero.</li> <li>The quantity of the product in the cart is updated in the database.</li> <li>The updated cart data is returned to the frontend.</li> </ol> <p>Scenario: A user views the current state of the cart.</p> <p>Flow:</p> <ol> <li>The user submits a \"view cart\" request.</li> <li>The backend retrieves all items in the user's cart from the database.</li> <li>The cart data is returned to the frontend with product details, quantities, and total cost.</li> </ol>"},{"location":"CS-Backend/CS-Backend/#order-processing","title":"Order Processing","text":"<p>Scenario: A customer places an order.</p> <p>Flow:</p> <ol> <li>Customer submits the order via the API.</li> <li>Backend verifies product availability and processes the order.</li> <li>Order status is updated and confirmation sent to the user.</li> </ol>"},{"location":"CS-Backend/CS-Backend/#basics-of-project-management","title":"Basics of Project Management","text":"<p>Estimated Timeline:</p> <ul> <li>Phase 1: Requirements Gathering (1-2 weeks): Define scope, features, and goals.</li> <li>Phase 2: Development (6-8 weeks): Implement core features and APIs.</li> </ul> <p>Milestones:</p> <ul> <li>Initial API setup and user authentication completed.</li> <li>Product management module operational.</li> <li>Full order processing workflow integrated.</li> <li>Deployment-ready Dockerized application.</li> </ul>"},{"location":"CS-Backend/CS-Backend/#code-structure","title":"Code Structure","text":"<p>High-Level Directory Layout:</p> <ul> <li>C# Backend (Documented here)</li> </ul> <p>Key Components:</p> <ul> <li>Controllers: Handle API requests and responses.</li> <li>Services: Contain business logic, including user management, product catalog operations, and db operations.</li> <li>Models: Define data structures and facilitate data exchange between layers.</li> <li>Data: Contain the DbContext configuration.</li> <li>Configuration: Centralized application settings for different environments.</li> </ul> <p>Documentation Links for Frameworks and Libraries:</p> <ul> <li>C# Documentation</li> <li>ASP.NET Core Documentation</li> <li>Microsoft SQL Server Documentation</li> <li>PostgreSQL Documentation</li> <li>JWT.io Documentation</li> <li>Dependency Injection in .NET</li> <li>Configuration in .NET</li> <li>Docker Documentation</li> <li>Docker Compose Documentation</li> </ul>"},{"location":"JavaScript-Backend/","title":"About the JavaScript backend","text":"<p>This is the JavaScript backend developed by @CommanderRedYT.</p>"},{"location":"JavaScript-Backend/#database","title":"Database","text":"<p>The database is initialized through a couple of SQL scripts.</p> <p>The final database looks like this:</p> <p></p>"},{"location":"api/","title":"API Definition","text":"<p>Our API is defined using the OpenAPI Specification (OAS) version 3.0.0. The API definition is in another repository and can be found here.</p> <p>The API definition is used to generate TypeScript types for the API. These types are used in the frontend to ensure type safety when interacting with the API.</p> <p>You can find a hosted version of the API documentation here. (Swagger UI)</p>"},{"location":"api/#backends","title":"Backends","text":"<p>There are two backends:     - C# Backend     - Node.js Backend</p> <p>The C# backend is the main backend for the project. The Node.js backend is a backup backend that can be used if the C# backend is not available or outdated.</p>"},{"location":"api/frontend-client/","title":"Frontend Client","text":"<p>For the API functions, we use an API client that is type-safe. The generation is provided by the <code>openapi-typescript</code> package.</p> <p>The API client is generated using the OpenAPI schema. The client is generated in the <code>src/utils/api.ts</code> file.</p> <p>The client is a set of functions that make requests to the API. The client is used in the frontend to interact with the API.</p>"},{"location":"developer/","title":"Developer Documentation","text":""},{"location":"developer/#mkdocs","title":"MKDocs","text":"<p>Here are some basic MKDocs commands:</p> <ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul> <p>For full documentation visit mkdocs.org.</p>"},{"location":"developer/#formatting-file-trees","title":"Formatting File Trees","text":"<p>We are using https://tree.nathanfriend.com to generate the file trees in the documentation.</p>"},{"location":"frontend/","title":"Storevision Webstore Frontend","text":""},{"location":"frontend/#project-structure","title":"Project structure","text":"<p>You can find more details about the project structure in the Project Structure documentation.</p>"},{"location":"project/backend/","title":"Backend Structure","text":"<p>Here is a overview about the backend folder structure:</p>"},{"location":"project/backend/#root-folder","title":"Root folder","text":"<pre><code>Webshop/\n\u251c\u2500\u2500 App/\n\u2502   \u2514\u2500\u2500 src/\n\u2502       \u2514\u2500\u2500 main/\n\u2502           \u251c\u2500\u2500 Controllers # contains all the logic for handling incoming requests and returning appropriate responses. \n\u2502           \u251c\u2500\u2500 Data # contains the dbcontext configuration.\n\u2502           \u251c\u2500\u2500 Models/\n\u2502           \u2502   \u251c\u2500\u2500 ApiHelper # base class for the controllers, handle responses.\n\u2502           \u2502   \u251c\u2500\u2500 DB-Models # all db-models for db-migration\n\u2502           \u2502   \u2514\u2500\u2500 Responses # response classes, to generate json objects.\n\u2502           \u2514\u2500\u2500 Services/\n\u2502               \u2514\u2500\u2500 ... # services that handle incoming requests, and create responses\n\u251c\u2500\u2500 sql /\n\u2502   \u2514\u2500\u2500 ... # script to insert test datas into the database\n\u251c\u2500\u2500 Migrations/\n\u2502   \u2514\u2500\u2500 ... # migration file to update changes on the db.\n\u251c\u2500\u2500 .gitignore # list of files what should be ignored\n\u251c\u2500\u2500 appsettings.json # settings for the application\n\u251c\u2500\u2500 appsettings.Development.json # configure the LogLevel\n\u251c\u2500\u2500 backend.env # environments for the connectionstring\n\u251c\u2500\u2500 docker-compose.yml # defines and manages multi-container Docker applications and their configurations.\n\u2514\u2500\u2500 Dockerfile # specifying the base image\n</code></pre>"},{"location":"project/frontend/","title":"Frontend Structure","text":"<p>Here is a overview about the frontend folder structure:</p>"},{"location":"project/frontend/#root-folder","title":"Root folder","text":"<pre><code>webstore-frontend/\n\u251c\u2500\u2500 .github/\n\u2502   \u2514\u2500\u2500 ...    # GitHub Configuration.\n\u251c\u2500\u2500 mkdocs.yml  # The configuration file for documentation.\n\u251c\u2500\u2500 docs/\n\u2502   \u2514\u2500\u2500 ...    # Markdown pages, images and other files for documentation.\n\u251c\u2500\u2500 e2e-tests/\n\u2502   \u2514\u2500\u2500 ...    # End-to-end tests implemented using Playwright.\n\u251c\u2500\u2500 public/\n\u2502   \u2514\u2500\u2500 ...    # Public files like images and other assets.\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 ...    # Source files\n\u251c\u2500\u2500 .editorconfig          # Editor configuration file.\n\u251c\u2500\u2500 .env                   # Environment variables.\n\u251c\u2500\u2500 .eslintrc.js           # ESLint configuration file. (Code formatting, linting)\n\u251c\u2500\u2500 .gitattributes         # Git attributes file. (Proper handling of line endings, etc.)\n\u251c\u2500\u2500 .gitignore             # Git ignore file.\n\u251c\u2500\u2500 .nvmrc                 # Node version manager configuration file. Used to specify the Node.js version.\n\u251c\u2500\u2500 Frontend.Dockerfile    # Dockerfile for building the frontend.\n\u251c\u2500\u2500 jest.config.ts         # Jest configuration file. (Unit testing)\n\u251c\u2500\u2500 LICENSE                # License file.\n\u251c\u2500\u2500 next.config.js         # Next.js configuration file.\n\u251c\u2500\u2500 next-env.d.ts          # Next.js typescript definitions.\n\u251c\u2500\u2500 package.json           # Node.js package file.\n\u251c\u2500\u2500 playwrigth.config.ts   # Playwright configuration file.\n\u251c\u2500\u2500 Playwright.Dockerfile  # Dockerfile for building the Playwright image.\n\u251c\u2500\u2500 README.md              # Readme file.\n\u251c\u2500\u2500 tsconfig.json          # TypeScript configuration file.\n\u2514\u2500\u2500 yarn.lock              # Yarn lock file.\n</code></pre>"},{"location":"project/frontend/#github-folder","title":"<code>.github/</code> folder","text":"<pre><code>.github/\n\u251c\u2500\u2500 workflows/\n\u2502   \u251c\u2500\u2500 ci.yml    # GitHub Actions workflow file for CI.\n\u2502   \u2514\u2500\u2500 docs.yml  # Configuration file for the mkdocs action.\n\u2514\u2500\u2500 dependabot.yml  # Dependabot configuration file.\n</code></pre> <p>The <code>.github/workflows</code> folder contains the GitHub Actions workflow files. Here, we have files describing the CI/CD pipeline for the project. These files contain tests to see if everything still works, check the code quality, and build + deploy the project.</p> <p>The <code>dependabot.yml</code> file contains the configuration for the Dependabot service. Dependabot checks for outdated dependencies and creates pull requests to update them.</p>"},{"location":"project/frontend/#docs-folder","title":"<code>docs/</code> folder","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md  # The documentation homepage.\n\u2514\u2500\u2500 ...       # Other markdown files for documentation.\n</code></pre> <p>Here you can find the documentation for the project. The documentation is written in markdown and can be viewed using the mkdocs tool.</p> <p>You can find more information about mkdocs here and our developer documentation here.</p>"},{"location":"project/frontend/#e2e-tests-folder","title":"<code>e2e-tests/</code> folder","text":"<pre><code>e2e-tests/\n\u2514\u2500\u2500 ...    # End-to-end tests implemented using Playwright.\n</code></pre> <p>This folder contains the end-to-end tests for the project. The tests are implemented using the Playwright testing framework.</p> <p>The tests define the behavior of the application from the user's perspective. They simulate user interactions with the application and check if the application behaves as expected.</p>"},{"location":"project/frontend/#src-folder","title":"<code>src/</code> folder","text":"<pre><code>src/\n\u251c\u2500\u2500 app/         # The Next.js app folder. Contains the pages and components.\n\u251c\u2500\u2500 components/  # Reusable components.\n\u251c\u2500\u2500 constants/   # Constants used in the app.\n\u251c\u2500\u2500 generated/   # Generated files by openapi-typescript codegen.\n\u251c\u2500\u2500 hooks/       # Custom hooks.\n\u251c\u2500\u2500 providers/   # Context providers.\n\u251c\u2500\u2500 stores/      # Zustand state management stores.\n\u251c\u2500\u2500 utils/       # Utility functions.\n\u251c\u2500\u2500 mui.ts       # @mui/material module augmentation.\n\u251c\u2500\u2500 theme.ts     # Material-UI theme.\n\u2514\u2500\u2500 types.d.ts   # TypeScript global types.\n</code></pre> <p>This is where the code of the project is located. The <code>src</code> folder contains the source files for the project.</p> <p>The <code>app</code> folder contains the Next.js app. It contains the pages and components that make up the application. You can read more about the Next.js app structure here.</p> <p>The <code>app</code> folder also contains a folder called <code>_api</code> which contains the API functions used to communicate with the backend. The reason this is inside the <code>app</code> folder is that these functions are server actions. Especially because of the <code>cookies()</code> function, which is only available on the server.</p>"},{"location":"project/frontend/#srcutilsapits-file","title":"<code>src/utils/api.ts</code> file","text":"<p>For the API functions, we use a API client that is type-safe. The generation is provided by the <code>openapi-typescript</code> package. The <code>openapi-fetch</code> package is used to take these generated types and create a fetch function that is type-safe.</p> <p>There are also some typescript generics that we have to extract things like a <code>SuccessResponse</code> or <code>ErrorResponse</code> from the API response.</p>"},{"location":"project/server-side-nodejs/","title":"Server-Side (Node.js)","text":""},{"location":"project/server-side-nodejs/#image-processing","title":"Image Processing","text":"<p>The backend image processing is done via Sharp. This is used for creating a thumbnail for the product images.</p>"},{"location":"project/technologies/","title":"Technologies","text":""},{"location":"project/technologies/#frontend","title":"Frontend","text":"<ul> <li>Next.js: A React framework for building web applications.</li> <li>React: A JavaScript library for building user interfaces.</li> <li>TypeScript: A typed superset of JavaScript that compiles to plain JavaScript.</li> <li>MUI (Material UI): A React component library implementing Google's Material Design.</li> <li>Zustand: A small, fast, and scalable state management library for React.</li> <li>Moment.js: A JavaScript date library for parsing, validating, manipulating, and formatting dates.</li> </ul>"},{"location":"project/technologies/#c-backend","title":"C# Backend","text":"<ul> <li>ASP.NET Core: A cross-platform, high-performance web framework for building modern, cloud-based, connected applications.</li> <li>Entity Framework Core: An ORM (Object-Relational Mapper) for .NET, simplifying data access and working with databases in C#.</li> <li>Microsoft.EntityFrameworkCore.SqlServer: Adds support for SQL Server.</li> <li>Npgsql.EntityFrameworkCore.PostgreSQL: Adds support for PostgreSQL.</li> <li>EntityFrameworkCore.Toolbox: A toolbox for working with Entity Framework Core, useful for migrations and reverse engineering.</li> <li>BCrypt.Net-Next: A library for securely hashing and verifying passwords using the BCrypt algorithm.</li> <li>DotNetEnv: A library to load environment variables from <code>.env</code> files into your application, often used for managing configuration.</li> <li>Microsoft.AspNetCore.Authentication.JwtBearer: Provides support for authenticating API requests using JSON Web Tokens (JWT).</li> <li>Swagger (Swashbuckle.AspNetCore): A framework for API documentation and design, enabling visualization and interaction with API endpoints.</li> <li>Swashbuckle.AspNetCore: A NuGet package for Swagger integration in ASP.NET Core.</li> <li>System.IdentityModel.Tokens.Jwt: A library for handling JWT tokens, commonly used for secure API authentication.</li> <li>SkiaSharp: A cross-platform 2D graphics library for rendering graphics.</li> <li>SkiaSharp.NativeAssets.Linux.NoDependencies: Provides native SkiaSharp assets for Linux.</li> <li>Static Assets: A collection of images and other files included in the <code>wwwroot/assets</code> folder, useful for UI or media content in the application.</li> </ul>"},{"location":"project/technologies/#nodejs-backend","title":"Node.js Backend","text":"<ul> <li>Express: A fast, unopinionated, minimalist web framework for Node.js.</li> <li>TypeScript: A typed superset of JavaScript that compiles to plain JavaScript.</li> <li>bcrypt: A library to help you hash passwords to store securely.</li> <li>jsonwebtoken: An implementation of JSON Web Tokens.</li> <li>fuse.js: A lightweight fuzzy-search library.</li> <li>morgan: HTTP request logger middleware for Node.js.</li> <li>pg: A PostgreSQL client for Node.js.</li> <li>dotenv: A zero-dependency module that loads environment variables from a <code>.env</code> file into <code>process.env</code>.</li> <li>sharp: High performance Node.js image processing. See Image Processing.</li> <li>ts-patch: Patch typescript to allow custom transformers (plugins) during build.</li> <li>simple-identicon: A simple identicon generator. (Actually written by one of us)</li> </ul>"},{"location":"project/technologies/#common-development-tools","title":"Common development tools","text":"<ul> <li>ESLint: A static code analysis tool for identifying problematic patterns found in JavaScript code.</li> <li>Prettier: An opinionated code formatter.</li> <li>Jest: A JavaScript testing framework.</li> <li>Playwright: A Node.js library to automate the Chromium, WebKit, and Firefox browsers with a single API.</li> <li>OpenAPI: A specification for building APIs.</li> <li>openapi-typescript: A tool to generate TypeScript types from an OpenAPI schema.</li> <li>patch-package: A tool to make changes to node modules that get overwritten by npm or yarn.</li> <li>yarn: A package manager for JavaScript.</li> <li>type-fest: A collection of essential TypeScript types.</li> <li>ts-node: TypeScript execution and REPL for Node.js.</li> <li>tsconfig-paths: A tool to load modules according to the paths specified in the <code>tsconfig.json</code> file.</li> <li>ts-jest: A TypeScript preprocessor with source map support for Jest.</li> <li>ts-node-dev: A development tool that restarts the server when changes are made.</li> </ul>"}]}